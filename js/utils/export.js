/**
 * Export Utilities
 * Functions for exporting measurements to PDF, Excel, and CSV
 */

/**
 * Export measurement to PDF
 * @param {Object} measurement - Measurement object
 * @param {string} canvasDataURL - Canvas image as data URL
 * @param {Object} projectInfo - Project information
 */
export function exportToPDF(measurement, canvasDataURL = null, projectInfo = {}) {
  if (typeof jsPDF === 'undefined') {
    console.error('jsPDF library not loaded');
    alert('PDF export not available. Please check your internet connection.');
    return;
  }

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  const { leftDistance, rightDistance, avgWidth, length, area, areaDecimal } = measurement.calculations;

  // Title
  doc.setFontSize(20);
  doc.setFont(undefined, 'bold');
  doc.text('Land Measurement Report', 105, 20, { align: 'center' });

  // Project info
  doc.setFontSize(10);
  doc.setFont(undefined, 'normal');
  const dateStr = new Date(measurement.timestamp).toLocaleString();
  doc.text(`Date: ${dateStr}`, 20, 30);

  if (projectInfo.name) {
    doc.text(`Project: ${projectInfo.name}`, 20, 36);
  }

  // Canvas image (if provided)
  if (canvasDataURL) {
    try {
      doc.addImage(canvasDataURL, 'PNG', 20, 45, 170, 100);
    } catch (error) {
      console.error('Error adding canvas to PDF:', error);
    }
  }

  let yPos = canvasDataURL ? 155 : 45;

  // Measurements section
  doc.setFontSize(14);
  doc.setFont(undefined, 'bold');
  doc.text('Measurements', 20, yPos);

  doc.setFontSize(11);
  doc.setFont(undefined, 'normal');
  yPos += 10;

  doc.text(`Left Distance: ${leftDistance.toFixed(3)} m (${metersToFeetInches(leftDistance)})`, 30, yPos);
  yPos += 7;

  doc.text(`Right Distance: ${rightDistance.toFixed(3)} m (${metersToFeetInches(rightDistance)})`, 30, yPos);
  yPos += 7;

  doc.text(`Average Width: ${avgWidth.toFixed(2)} m`, 30, yPos);
  yPos += 7;

  doc.text(`Length: ${length.toFixed(2)} m`, 30, yPos);
  yPos += 10;

  doc.setFontSize(12);
  doc.setFont(undefined, 'bold');
  doc.text(`Total Area: ${area.toFixed(2)} sq ft (${areaDecimal.toFixed(3)} decimal)`, 30, yPos);

  yPos += 15;

  // Coordinates section
  doc.setFontSize(14);
  doc.setFont(undefined, 'bold');
  doc.text('Coordinates', 20, yPos);

  doc.setFontSize(10);
  doc.setFont(undefined, 'normal');
  yPos += 8;

  doc.text('Left Side Points:', 30, yPos);
  yPos += 6;

  measurement.leftPoints.forEach((pt, i) => {
    doc.text(`  ${i + 1}. (${pt.x}, ${pt.y})`, 35, yPos);
    yPos += 5;
  });

  yPos += 5;
  doc.text('Right Side Points:', 30, yPos);
  yPos += 6;

  measurement.rightPoints.forEach((pt, i) => {
    doc.text(`  ${i + 1}. (${pt.x}, ${pt.y})`, 35, yPos);
    yPos += 5;
  });

  // Notes (if any)
  if (measurement.notes) {
    yPos += 10;
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('Notes:', 20, yPos);

    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    yPos += 6;

    const splitNotes = doc.splitTextToSize(measurement.notes, 170);
    doc.text(splitNotes, 30, yPos);
  }

  // Footer
  doc.setFontSize(8);
  doc.setTextColor(128);
  doc.text('Generated by Land Distance & Area Calculator', 105, 285, { align: 'center' });

  // Save PDF
  const filename = `land_measurement_${Date.now()}.pdf`;
  doc.save(filename);
}

/**
 * Export measurements to Excel
 * @param {Array} measurements - Array of measurement objects
 * @param {Object} projectInfo - Project information
 */
export function exportToExcel(measurements, projectInfo = {}) {
  if (typeof XLSX === 'undefined') {
    console.error('XLSX library not loaded');
    alert('Excel export not available. Please check your internet connection.');
    return;
  }

  const wb = XLSX.utils.book_new();

  // Summary sheet
  const summaryData = measurements.map((m, idx) => ({
    'No.': idx + 1,
    'Date': new Date(m.timestamp).toLocaleString(),
    'Left Distance (m)': parseFloat(m.calculations.leftDistance.toFixed(3)),
    'Right Distance (m)': parseFloat(m.calculations.rightDistance.toFixed(3)),
    'Avg Width (m)': parseFloat(m.calculations.avgWidth.toFixed(2)),
    'Length (m)': parseFloat(m.calculations.length.toFixed(2)),
    'Area (sq ft)': parseFloat(m.calculations.area.toFixed(2)),
    'Area (decimal)': parseFloat(m.calculations.areaDecimal.toFixed(3)),
    'Notes': m.notes || ''
  }));

  const wsSummary = XLSX.utils.json_to_sheet(summaryData);

  // Set column widths
  wsSummary['!cols'] = [
    { wch: 5 },   // No.
    { wch: 20 },  // Date
    { wch: 18 },  // Left Distance
    { wch: 18 },  // Right Distance
    { wch: 15 },  // Avg Width
    { wch: 12 },  // Length
    { wch: 15 },  // Area (sq ft)
    { wch: 15 },  // Area (decimal)
    { wch: 30 }   // Notes
  ];

  XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

  // Coordinates sheet
  const coordsData = [];

  measurements.forEach((m, idx) => {
    // Header for this measurement
    coordsData.push({
      'Measurement': `#${idx + 1}`,
      'Date': new Date(m.timestamp).toLocaleString(),
      'Side': '',
      'Point': '',
      'X': '',
      'Y': ''
    });

    // Left points
    coordsData.push({
      'Measurement': '',
      'Date': '',
      'Side': 'Left',
      'Point': '',
      'X': '',
      'Y': ''
    });

    m.leftPoints.forEach((pt, i) => {
      coordsData.push({
        'Measurement': '',
        'Date': '',
        'Side': '',
        'Point': i + 1,
        'X': pt.x,
        'Y': pt.y
      });
    });

    // Right points
    coordsData.push({
      'Measurement': '',
      'Date': '',
      'Side': 'Right',
      'Point': '',
      'X': '',
      'Y': ''
    });

    m.rightPoints.forEach((pt, i) => {
      coordsData.push({
        'Measurement': '',
        'Date': '',
        'Side': '',
        'Point': i + 1,
        'X': pt.x,
        'Y': pt.y
      });
    });

    // Empty row separator
    coordsData.push({
      'Measurement': '',
      'Date': '',
      'Side': '',
      'Point': '',
      'X': '',
      'Y': ''
    });
  });

  const wsCoords = XLSX.utils.json_to_sheet(coordsData);

  // Set column widths
  wsCoords['!cols'] = [
    { wch: 15 },  // Measurement
    { wch: 20 },  // Date
    { wch: 10 },  // Side
    { wch: 8 },   // Point
    { wch: 12 },  // X
    { wch: 12 }   // Y
  ];

  XLSX.utils.book_append_sheet(wb, wsCoords, 'Coordinates');

  // Save file
  const filename = projectInfo.name
    ? `${projectInfo.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.xlsx`
    : `land_measurements_${Date.now()}.xlsx`;

  XLSX.writeFile(wb, filename);
}

/**
 * Export measurement to CSV
 * @param {Object} measurement - Measurement object
 */
export function exportToCSV(measurement) {
  const { leftDistance, rightDistance, avgWidth, length, area, areaDecimal } = measurement.calculations;

  // Build CSV content
  let csv = 'Land Measurement Report\n\n';

  csv += 'Date,' + new Date(measurement.timestamp).toLocaleString() + '\n\n';

  csv += 'Measurements\n';
  csv += 'Metric,Value,Unit\n';
  csv += `Left Distance,${leftDistance.toFixed(3)},m\n`;
  csv += `Right Distance,${rightDistance.toFixed(3)},m\n`;
  csv += `Average Width,${avgWidth.toFixed(2)},m\n`;
  csv += `Length,${length.toFixed(2)},m\n`;
  csv += `Area,${area.toFixed(2)},sq ft\n`;
  csv += `Area,${areaDecimal.toFixed(3)},decimal\n\n`;

  csv += 'Coordinates\n';
  csv += 'Side,Point,X,Y\n';

  measurement.leftPoints.forEach((pt, i) => {
    csv += `Left,${i + 1},${pt.x},${pt.y}\n`;
  });

  measurement.rightPoints.forEach((pt, i) => {
    csv += `Right,${i + 1},${pt.x},${pt.y}\n`;
  });

  if (measurement.notes) {
    csv += '\nNotes\n';
    csv += `"${measurement.notes.replace(/"/g, '""')}"\n`;
  }

  // Create blob and download
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `land_measurement_${Date.now()}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}

/**
 * Helper function to convert meters to feet and inches
 */
function metersToFeetInches(meters) {
  const inches = Math.round(meters * 39.3701);
  const ft = Math.floor(inches / 12);
  const inch = inches % 12;
  return `${ft} ft ${inch} in`;
}

/**
 * Export project data as JSON
 * @param {Object} project - Project object
 */
export function exportProjectJSON(project) {
  const exportData = {
    version: '1.0.0',
    exportedAt: new Date().toISOString(),
    application: 'Land Distance & Area Calculator',
    project: project.toJSON ? project.toJSON() : project
  };

  const json = JSON.stringify(exportData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `${project.name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}

/**
 * Export all application data (backup)
 * @param {Array} projects - All projects
 * @param {Object} settings - Application settings
 */
export function exportAllData(projects, settings) {
  const exportData = {
    version: '1.0.0',
    exportedAt: new Date().toISOString(),
    application: 'Land Distance & Area Calculator',
    projects: projects.map(p => p.toJSON ? p.toJSON() : p),
    settings: settings
  };

  const json = JSON.stringify(exportData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `land_calc_backup_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}

export default {
  exportToPDF,
  exportToExcel,
  exportToCSV,
  exportProjectJSON,
  exportAllData
};
